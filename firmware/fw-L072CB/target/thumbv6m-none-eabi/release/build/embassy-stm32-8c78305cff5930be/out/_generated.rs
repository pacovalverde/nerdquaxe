embassy_hal_internal :: peripherals_definition ! (ADC , CRC , CRS , DAC , DBGMCU , DMA1 , FLASH , PA0 , PA1 , PA2 , PA3 , PA4 , PA5 , PA6 , PA7 , PA8 , PA9 , PA10 , PA11 , PA12 , PA13 , PA14 , PA15 , PB0 , PB1 , PB2 , PB3 , PB4 , PB5 , PB6 , PB7 , PB8 , PB9 , PB10 , PB11 , PB12 , PB13 , PB14 , PB15 , PC0 , PC1 , PC2 , PC3 , PC4 , PC5 , PC6 , PC7 , PC8 , PC9 , PC10 , PC11 , PC12 , PC13 , PC14 , PC15 , PD0 , PD1 , PD2 , PD3 , PD4 , PD5 , PD6 , PD7 , PD8 , PD9 , PD10 , PD11 , PD12 , PD13 , PD14 , PD15 , PE0 , PE1 , PE2 , PE3 , PE4 , PE5 , PE6 , PE7 , PE8 , PE9 , PE10 , PE11 , PE12 , PE13 , PE14 , PE15 , PH0 , PH1 , PH2 , PH3 , PH4 , PH5 , PH6 , PH7 , PH8 , PH9 , PH10 , PH11 , PH12 , PH13 , PH14 , PH15 , I2C1 , I2C2 , I2C3 , IWDG , LPTIM1 , LPUART1 , PWR , MCO , RCC , RNG , RTC , SPI1 , SPI2 , SYSCFG , TIM2 , TIM21 , TIM22 , TIM3 , TIM6 , TIM7 , TSC , UID , USART1 , USART2 , USART4 , USART5 , USB , USBRAM , WWDG , EXTI0 , EXTI1 , EXTI2 , EXTI3 , EXTI4 , EXTI5 , EXTI6 , EXTI7 , EXTI8 , EXTI9 , EXTI10 , EXTI11 , EXTI12 , EXTI13 , EXTI14 , EXTI15 , DMA1_CH1 , DMA1_CH2 , DMA1_CH3 , DMA1_CH4 , DMA1_CH5 , DMA1_CH6 , DMA1_CH7) ; embassy_hal_internal :: peripherals_struct ! (ADC , CRC , CRS , DAC , DBGMCU , DMA1 , FLASH , PA0 , PA1 , PA2 , PA3 , PA4 , PA5 , PA6 , PA7 , PA8 , PA9 , PA10 , PA11 , PA12 , PA13 , PA14 , PA15 , PB0 , PB1 , PB2 , PB3 , PB4 , PB5 , PB6 , PB7 , PB8 , PB9 , PB10 , PB11 , PB12 , PB13 , PB14 , PB15 , PC0 , PC1 , PC2 , PC3 , PC4 , PC5 , PC6 , PC7 , PC8 , PC9 , PC10 , PC11 , PC12 , PC13 , PC14 , PC15 , PD0 , PD1 , PD2 , PD3 , PD4 , PD5 , PD6 , PD7 , PD8 , PD9 , PD10 , PD11 , PD12 , PD13 , PD14 , PD15 , PE0 , PE1 , PE2 , PE3 , PE4 , PE5 , PE6 , PE7 , PE8 , PE9 , PE10 , PE11 , PE12 , PE13 , PE14 , PE15 , PH0 , PH1 , PH2 , PH3 , PH4 , PH5 , PH6 , PH7 , PH8 , PH9 , PH10 , PH11 , PH12 , PH13 , PH14 , PH15 , I2C1 , I2C2 , I2C3 , IWDG , LPTIM1 , LPUART1 , PWR , MCO , RCC , RNG , RTC , SPI1 , SPI2 , SYSCFG , TIM2 , TIM21 , TIM22 , TIM6 , TIM7 , TSC , UID , USART1 , USART2 , USART4 , USART5 , USB , USBRAM , WWDG , EXTI0 , EXTI1 , EXTI2 , EXTI3 , EXTI4 , EXTI5 , EXTI6 , EXTI7 , EXTI8 , EXTI9 , EXTI10 , EXTI11 , EXTI12 , EXTI13 , EXTI14 , EXTI15 , DMA1_CH1 , DMA1_CH2 , DMA1_CH3 , DMA1_CH4 , DMA1_CH5 , DMA1_CH6 , DMA1_CH7) ; embassy_hal_internal :: interrupt_mod ! (WWDG , PVD , RTC , FLASH , RCC_CRS , EXTI0_1 , EXTI2_3 , EXTI4_15 , TSC , DMA1_CHANNEL1 , DMA1_CHANNEL2_3 , DMA1_CHANNEL4_5_6_7 , ADC1_COMP , LPTIM1 , USART4_5 , TIM2 , TIM3 , TIM6_DAC , TIM7 , TIM21 , I2C3 , TIM22 , I2C1 , I2C2 , SPI1 , SPI2 , USART1 , USART2 , RNG_LPUART1 , USB ,) ; pub const MAX_ERASE_SIZE : usize = 128u32 as usize ; pub mod flash_regions { pub const BANK1_REGION : crate :: flash :: FlashRegion = crate :: flash :: FlashRegion { bank : crate :: flash :: FlashBank :: Bank1 , base : 134217728u32 , size : 131072u32 , erase_size : 128u32 , write_size : 4u32 , erase_value : 0u8 , _ensure_internal : () , } ; # [cfg (flash)] pub struct Bank1Region < 'd , MODE = crate :: flash :: Async > (pub & 'static crate :: flash :: FlashRegion , pub (crate) embassy_hal_internal :: PeripheralRef < 'd , crate :: peripherals :: FLASH > , pub (crate) core :: marker :: PhantomData < MODE >) ; # [cfg (flash)] pub struct FlashLayout < 'd , MODE = crate :: flash :: Async > { pub bank1_region : Bank1Region < 'd , MODE > , _mode : core :: marker :: PhantomData < MODE > , } # [cfg (flash)] impl < 'd , MODE > FlashLayout < 'd , MODE > { pub (crate) fn new (p : embassy_hal_internal :: PeripheralRef < 'd , crate :: peripherals :: FLASH >) -> Self { Self { bank1_region : Bank1Region (& BANK1_REGION , unsafe { p . clone_unchecked () } , core :: marker :: PhantomData) , _mode : core :: marker :: PhantomData , } } } pub const FLASH_REGIONS : [& crate :: flash :: FlashRegion ; 1usize] = [& BANK1_REGION] ; } impl crate :: rcc :: SealedRccPeripheral for peripherals :: ADC { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_adcrst (true)) ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_adcen (true)) ; let _ = crate :: pac :: RCC . apb2enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_adcrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_adcen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: ADC { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: CRC { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_crcrst (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_crcen (true)) ; let _ = crate :: pac :: RCC . ahbenr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_crcrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_crcen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: CRC { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: CRS { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_crsrst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_crsen (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_crsrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_crsen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: CRS { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: DAC { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_dacrst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_dacen (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_dacrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_dacen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: DAC { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: DMA1 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_dma1rst (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_dma1en (true)) ; let _ = crate :: pac :: RCC . ahbenr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_dma1rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_dma1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: DMA1 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: I2C1 { fn frequency () -> crate :: time :: Hertz { match crate :: pac :: RCC . ccipr () . read () . i2c1sel () { crate :: pac :: rcc :: vals :: I2csel :: PCLK1 => unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } , crate :: pac :: rcc :: vals :: I2csel :: SYS => unsafe { crate :: rcc :: get_freqs () . sys . unwrap () } , crate :: pac :: rcc :: vals :: I2csel :: HSI => unsafe { crate :: rcc :: get_freqs () . hsi . unwrap () } , # [allow (unreachable_patterns)] _ => unreachable ! () , } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c1rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c1en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c1rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: I2C1 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: I2C2 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c2rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c2en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c2rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c2en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: I2C2 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: I2C3 { fn frequency () -> crate :: time :: Hertz { match crate :: pac :: RCC . ccipr () . read () . i2c3sel () { crate :: pac :: rcc :: vals :: I2csel :: PCLK1 => unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } , crate :: pac :: rcc :: vals :: I2csel :: SYS => unsafe { crate :: rcc :: get_freqs () . sys . unwrap () } , crate :: pac :: rcc :: vals :: I2csel :: HSI => unsafe { crate :: rcc :: get_freqs () . hsi . unwrap () } , # [allow (unreachable_patterns)] _ => unreachable ! () , } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c3rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c3en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c3rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c3en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: I2C3 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: LPTIM1 { fn frequency () -> crate :: time :: Hertz { match crate :: pac :: RCC . ccipr () . read () . lptim1sel () { crate :: pac :: rcc :: vals :: Lptimsel :: PCLK1 => unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } , crate :: pac :: rcc :: vals :: Lptimsel :: LSI => unsafe { crate :: rcc :: get_freqs () . lsi . unwrap () } , crate :: pac :: rcc :: vals :: Lptimsel :: HSI => unsafe { crate :: rcc :: get_freqs () . hsi . unwrap () } , crate :: pac :: rcc :: vals :: Lptimsel :: LSE => unsafe { crate :: rcc :: get_freqs () . lse . unwrap () } , # [allow (unreachable_patterns)] _ => unreachable ! () , } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP2 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_lptim1rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_lptim1en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_lptim1rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_lptim1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP2 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: LPTIM1 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: LPUART1 { fn frequency () -> crate :: time :: Hertz { match crate :: pac :: RCC . ccipr () . read () . lpuart1sel () { crate :: pac :: rcc :: vals :: Uartsel :: PCLK1 => unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } , crate :: pac :: rcc :: vals :: Uartsel :: SYS => unsafe { crate :: rcc :: get_freqs () . sys . unwrap () } , crate :: pac :: rcc :: vals :: Uartsel :: HSI => unsafe { crate :: rcc :: get_freqs () . hsi . unwrap () } , crate :: pac :: rcc :: vals :: Uartsel :: LSE => unsafe { crate :: rcc :: get_freqs () . lse . unwrap () } , # [allow (unreachable_patterns)] _ => unreachable ! () , } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_LPUART1EN += 1 } ; if unsafe { refcount_statics :: APB1ENR_LPUART1EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP2 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_lpuart1rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_lpuart1en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_lpuart1rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_LPUART1EN -= 1 } ; if unsafe { refcount_statics :: APB1ENR_LPUART1EN } > 0 { return ; } crate :: pac :: RCC . apb1enr () . modify (| w | w . set_lpuart1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP2 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: LPUART1 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: PWR { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_pwrrst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_pwren (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_pwrrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_pwren (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: PWR { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: RNG { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_rngrst (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_rngen (true)) ; let _ = crate :: pac :: RCC . ahbenr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_rngrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_rngen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: RNG { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: SPI1 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_spi1rst (true)) ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_spi1en (true)) ; let _ = crate :: pac :: RCC . apb2enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_spi1rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_spi1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: SPI1 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: SPI2 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_spi2rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_spi2en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_spi2rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_spi2en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: SPI2 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: SYSCFG { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_syscfgrst (true)) ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_syscfgen (true)) ; let _ = crate :: pac :: RCC . apb2enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_syscfgrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_syscfgen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: SYSCFG { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: TIM2 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1_tim . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim2rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim2en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim2rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim2en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM2 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: TIM21 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2_tim . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim21rst (true)) ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim21en (true)) ; let _ = crate :: pac :: RCC . apb2enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim21rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim21en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM21 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: TIM22 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2_tim . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim22rst (true)) ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim22en (true)) ; let _ = crate :: pac :: RCC . apb2enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim22rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim22en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM22 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: TIM3 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1_tim . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim3rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim3en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim3rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim3en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM3 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: TIM6 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1_tim . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim6rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim6en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim6rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim6en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM6 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: TIM7 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1_tim . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim7rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim7en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim7rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim7en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM7 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: USART1 { fn frequency () -> crate :: time :: Hertz { match crate :: pac :: RCC . ccipr () . read () . usart1sel () { crate :: pac :: rcc :: vals :: Usart1sel :: PCLK2 => unsafe { crate :: rcc :: get_freqs () . pclk2 . unwrap () } , crate :: pac :: rcc :: vals :: Usart1sel :: SYS => unsafe { crate :: rcc :: get_freqs () . sys . unwrap () } , crate :: pac :: rcc :: vals :: Usart1sel :: HSI => unsafe { crate :: rcc :: get_freqs () . hsi . unwrap () } , crate :: pac :: rcc :: vals :: Usart1sel :: LSE => unsafe { crate :: rcc :: get_freqs () . lse . unwrap () } , # [allow (unreachable_patterns)] _ => unreachable ! () , } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB2ENR_USART1EN += 1 } ; if unsafe { refcount_statics :: APB2ENR_USART1EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_usart1rst (true)) ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_usart1en (true)) ; let _ = crate :: pac :: RCC . apb2enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_usart1rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB2ENR_USART1EN -= 1 } ; if unsafe { refcount_statics :: APB2ENR_USART1EN } > 0 { return ; } crate :: pac :: RCC . apb2enr () . modify (| w | w . set_usart1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: USART1 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: USART2 { fn frequency () -> crate :: time :: Hertz { match crate :: pac :: RCC . ccipr () . read () . usart2sel () { crate :: pac :: rcc :: vals :: Uartsel :: PCLK1 => unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } , crate :: pac :: rcc :: vals :: Uartsel :: SYS => unsafe { crate :: rcc :: get_freqs () . sys . unwrap () } , crate :: pac :: rcc :: vals :: Uartsel :: HSI => unsafe { crate :: rcc :: get_freqs () . hsi . unwrap () } , crate :: pac :: rcc :: vals :: Uartsel :: LSE => unsafe { crate :: rcc :: get_freqs () . lse . unwrap () } , # [allow (unreachable_patterns)] _ => unreachable ! () , } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_USART2EN += 1 } ; if unsafe { refcount_statics :: APB1ENR_USART2EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usart2rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usart2en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usart2rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_USART2EN -= 1 } ; if unsafe { refcount_statics :: APB1ENR_USART2EN } > 0 { return ; } crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usart2en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: USART2 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: USART4 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_USART4EN += 1 } ; if unsafe { refcount_statics :: APB1ENR_USART4EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usart4rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usart4en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usart4rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_USART4EN -= 1 } ; if unsafe { refcount_statics :: APB1ENR_USART4EN } > 0 { return ; } crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usart4en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: USART4 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: USART5 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_USART5EN += 1 } ; if unsafe { refcount_statics :: APB1ENR_USART5EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usart5rst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usart5en (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usart5rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_USART5EN -= 1 } ; if unsafe { refcount_statics :: APB1ENR_USART5EN } > 0 { return ; } crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usart5en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: USART5 { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: USB { fn frequency () -> crate :: time :: Hertz { match crate :: pac :: RCC . ccipr () . read () . clk48sel () { crate :: pac :: rcc :: vals :: Clk48sel :: PLL1_VCO_DIV_2 => unsafe { crate :: rcc :: get_freqs () . pll1_vco_div_2 . unwrap () } , crate :: pac :: rcc :: vals :: Clk48sel :: HSI48 => unsafe { crate :: rcc :: get_freqs () . hsi48 . unwrap () } , # [allow (unreachable_patterns)] _ => unreachable ! () , } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usbrst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usben (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usbrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usben (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: USB { } impl crate :: rcc :: SealedRccPeripheral for peripherals :: WWDG { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 . unwrap () } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_wwdgrst (true)) ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_wwdgen (true)) ; let _ = crate :: pac :: RCC . apb1enr () . read () ; cortex_m :: asm :: dsb () ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_wwdgrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_wwdgen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: WWDG { } pub mod mux { pub use crate :: pac :: rcc :: vals :: Clk48sel as Clk48sel ; pub use crate :: pac :: rcc :: vals :: I2csel as I2csel ; pub use crate :: pac :: rcc :: vals :: Lptimsel as Lptimsel ; pub use crate :: pac :: rcc :: vals :: Uartsel as Uartsel ; pub use crate :: pac :: rcc :: vals :: Usart1sel as Usart1sel ; # [derive (Clone , Copy)] pub struct ClockMux { pub clk48sel : Clk48sel , pub i2c1sel : I2csel , pub i2c3sel : I2csel , pub lptim1sel : Lptimsel , pub lpuart1sel : Uartsel , pub usart1sel : Usart1sel , pub usart2sel : Uartsel , } impl ClockMux { pub (crate) const fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } impl Default for ClockMux { fn default () -> Self { Self :: default () } } impl ClockMux { pub (crate) fn init (& self) { crate :: pac :: RCC . ccipr () . modify (| w | { w . set_clk48sel (self . clk48sel) ; w . set_i2c1sel (self . i2c1sel) ; w . set_i2c3sel (self . i2c3sel) ; w . set_lptim1sel (self . lptim1sel) ; w . set_lpuart1sel (self . lpuart1sel) ; w . set_usart1sel (self . usart1sel) ; w . set_usart2sel (self . usart2sel) ; }) ; } } } # [derive (Clone , Copy , Debug)] # [cfg_attr (feature = "defmt" , derive (defmt :: Format))] pub struct Clocks { pub hclk1 : Option < crate :: time :: Hertz > , pub hsi : Option < crate :: time :: Hertz > , pub hsi48 : Option < crate :: time :: Hertz > , pub lse : Option < crate :: time :: Hertz > , pub lsi : Option < crate :: time :: Hertz > , pub pclk1 : Option < crate :: time :: Hertz > , pub pclk1_tim : Option < crate :: time :: Hertz > , pub pclk2 : Option < crate :: time :: Hertz > , pub pclk2_tim : Option < crate :: time :: Hertz > , pub pll1_vco_div_2 : Option < crate :: time :: Hertz > , pub rtc : Option < crate :: time :: Hertz > , pub sys : Option < crate :: time :: Hertz > , } mod refcount_statics { pub (crate) static mut APB1ENR_LPUART1EN : u8 = 0 ; pub (crate) static mut APB1ENR_USART2EN : u8 = 0 ; pub (crate) static mut APB1ENR_USART4EN : u8 = 0 ; pub (crate) static mut APB1ENR_USART5EN : u8 = 0 ; pub (crate) static mut APB2ENR_USART1EN : u8 = 0 ; } pub unsafe fn init_dma () { } pub unsafe fn init_bdma () { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_dma1en (true)) ; } pub unsafe fn init_dmamux () { } pub unsafe fn init_gpdma () { } pub unsafe fn init_gpio () { crate :: pac :: RCC . gpioenr () . modify (| w | w . set_gpioaen (true)) ; crate :: pac :: RCC . gpioenr () . modify (| w | w . set_gpioben (true)) ; crate :: pac :: RCC . gpioenr () . modify (| w | w . set_gpiocen (true)) ; crate :: pac :: RCC . gpioenr () . modify (| w | w . set_gpioden (true)) ; crate :: pac :: RCC . gpioenr () . modify (| w | w . set_gpioeen (true)) ; crate :: pac :: RCC . gpioenr () . modify (| w | w . set_gpiohen (true)) ; } impl_adc_pin ! (ADC , PA0 , 0u8) ; impl_adc_pin ! (ADC , PA1 , 1u8) ; impl_adc_pin ! (ADC , PA2 , 2u8) ; impl_adc_pin ! (ADC , PA3 , 3u8) ; impl_adc_pin ! (ADC , PA4 , 4u8) ; impl_adc_pin ! (ADC , PA5 , 5u8) ; impl_adc_pin ! (ADC , PA6 , 6u8) ; impl_adc_pin ! (ADC , PA7 , 7u8) ; impl_adc_pin ! (ADC , PB0 , 8u8) ; impl_adc_pin ! (ADC , PB1 , 9u8) ; impl_adc_pin ! (ADC , PC0 , 10u8) ; impl_adc_pin ! (ADC , PC1 , 11u8) ; impl_adc_pin ! (ADC , PC2 , 12u8) ; impl_dac_pin ! (DAC , PA4 , 1u8) ; impl_dac_pin ! (DAC , PA5 , 2u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C1 , PA10 , 6u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C1 , PA9 , 6u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C1 , PB6 , 1u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C1 , PB7 , 1u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C1 , PB8 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C1 , PB9 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C2 , PB10 , 6u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C2 , PB11 , 6u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C2 , PB13 , 5u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C2 , PB14 , 5u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C3 , PA8 , 7u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C3 , PB4 , 7u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C3 , PC0 , 7u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C3 , PC1 , 7u8) ; pin_trait_impl ! (crate :: usart :: RxPin , LPUART1 , PA13 , 6u8) ; pin_trait_impl ! (crate :: usart :: TxPin , LPUART1 , PA14 , 6u8) ; pin_trait_impl ! (crate :: usart :: TxPin , LPUART1 , PA2 , 6u8) ; pin_trait_impl ! (crate :: usart :: RxPin , LPUART1 , PA3 , 6u8) ; pin_trait_impl ! (crate :: usart :: CtsPin , LPUART1 , PA6 , 4u8) ; pin_trait_impl ! (crate :: usart :: DePin , LPUART1 , PB1 , 4u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , LPUART1 , PB1 , 4u8) ; pin_trait_impl ! (crate :: usart :: RxPin , LPUART1 , PB10 , 7u8) ; pin_trait_impl ! (crate :: usart :: TxPin , LPUART1 , PB10 , 4u8) ; pin_trait_impl ! (crate :: usart :: RxPin , LPUART1 , PB11 , 4u8) ; pin_trait_impl ! (crate :: usart :: TxPin , LPUART1 , PB11 , 7u8) ; pin_trait_impl ! (crate :: usart :: DePin , LPUART1 , PB12 , 2u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , LPUART1 , PB12 , 2u8) ; pin_trait_impl ! (crate :: usart :: CtsPin , LPUART1 , PB13 , 4u8) ; pin_trait_impl ! (crate :: usart :: DePin , LPUART1 , PB14 , 4u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , LPUART1 , PB14 , 4u8) ; pin_trait_impl ! (crate :: usart :: RxPin , LPUART1 , PC0 , 6u8) ; pin_trait_impl ! (crate :: usart :: TxPin , LPUART1 , PC1 , 6u8) ; pin_trait_impl ! (crate :: rcc :: McoPin , MCO , PA8 , 0u8) ; pin_trait_impl ! (crate :: rcc :: McoPin , MCO , PA9 , 0u8) ; pin_trait_impl ! (crate :: rcc :: McoPin , MCO , PB13 , 2u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI1 , PA11 , 0u8) ; pin_trait_impl ! (crate :: spi :: MosiPin , SPI1 , PA12 , 0u8) ; pin_trait_impl ! (crate :: spi :: CsPin , SPI1 , PA15 , 0u8) ; pin_trait_impl ! (crate :: spi :: CsPin , SPI1 , PA4 , 0u8) ; pin_trait_impl ! (crate :: spi :: SckPin , SPI1 , PA5 , 0u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI1 , PA6 , 0u8) ; pin_trait_impl ! (crate :: spi :: MosiPin , SPI1 , PA7 , 0u8) ; pin_trait_impl ! (crate :: spi :: SckPin , SPI1 , PB3 , 0u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI1 , PB4 , 0u8) ; pin_trait_impl ! (crate :: spi :: MosiPin , SPI1 , PB5 , 0u8) ; pin_trait_impl ! (crate :: spi :: SckPin , SPI2 , PB10 , 5u8) ; pin_trait_impl ! (crate :: spi :: WsPin , SPI2 , PB12 , 0u8) ; pin_trait_impl ! (crate :: spi :: CsPin , SPI2 , PB12 , 0u8) ; pin_trait_impl ! (crate :: spi :: CkPin , SPI2 , PB13 , 0u8) ; pin_trait_impl ! (crate :: spi :: SckPin , SPI2 , PB13 , 0u8) ; pin_trait_impl ! (crate :: spi :: MckPin , SPI2 , PB14 , 0u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI2 , PB14 , 0u8) ; pin_trait_impl ! (crate :: spi :: MosiPin , SPI2 , PB15 , 0u8) ; pin_trait_impl ! (crate :: spi :: WsPin , SPI2 , PB9 , 5u8) ; pin_trait_impl ! (crate :: spi :: CsPin , SPI2 , PB9 , 5u8) ; pin_trait_impl ! (crate :: spi :: MckPin , SPI2 , PC2 , 2u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI2 , PC2 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM2 , PA0 , 2u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM2 , PA0 , 5u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM2 , PA1 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM2 , PA15 , 5u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM2 , PA15 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM2 , PA2 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM2 , PA3 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM2 , PA5 , 5u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM2 , PA5 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM2 , PB10 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM2 , PB11 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM2 , PB3 , 2u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM21 , PA1 , 5u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM21 , PA2 , 0u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM21 , PA3 , 0u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM21 , PB13 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM21 , PB14 , 6u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM22 , PA4 , 5u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM22 , PA6 , 5u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM22 , PA7 , 5u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM22 , PB4 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM22 , PB5 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM3 , PA6 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM3 , PA7 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM3 , PB0 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM3 , PB1 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM3 , PB4 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM3 , PB5 , 4u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART1 , PA10 , 4u8) ; pin_trait_impl ! (crate :: usart :: CtsPin , USART1 , PA11 , 4u8) ; pin_trait_impl ! (crate :: usart :: DePin , USART1 , PA12 , 4u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , USART1 , PA12 , 4u8) ; pin_trait_impl ! (crate :: usart :: CkPin , USART1 , PA8 , 4u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART1 , PA9 , 4u8) ; pin_trait_impl ! (crate :: usart :: DePin , USART1 , PB3 , 5u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , USART1 , PB3 , 5u8) ; pin_trait_impl ! (crate :: usart :: CtsPin , USART1 , PB4 , 5u8) ; pin_trait_impl ! (crate :: usart :: CkPin , USART1 , PB5 , 5u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART1 , PB6 , 0u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART1 , PB7 , 0u8) ; pin_trait_impl ! (crate :: usart :: CtsPin , USART2 , PA0 , 4u8) ; pin_trait_impl ! (crate :: usart :: DePin , USART2 , PA1 , 4u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , USART2 , PA1 , 4u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART2 , PA14 , 4u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART2 , PA15 , 4u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART2 , PA2 , 4u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART2 , PA3 , 4u8) ; pin_trait_impl ! (crate :: usart :: CkPin , USART2 , PA4 , 4u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART4 , PA0 , 6u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART4 , PA1 , 6u8) ; pin_trait_impl ! (crate :: usart :: DePin , USART4 , PA15 , 6u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , USART4 , PA15 , 6u8) ; pin_trait_impl ! (crate :: usart :: CtsPin , USART4 , PB7 , 6u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART5 , PB3 , 6u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART5 , PB4 , 6u8) ; pin_trait_impl ! (crate :: usart :: CkPin , USART5 , PB5 , 6u8) ; pin_trait_impl ! (crate :: usart :: DePin , USART5 , PB5 , 6u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , USART5 , PB5 , 6u8) ; pin_trait_impl ! (crate :: usb :: DmPin , USB , PA11 , 0u8) ; pin_trait_impl ! (crate :: usb :: DpPin , USB , PA12 , 0u8) ; dma_trait_impl ! (crate :: dac :: DacDma1 , DAC , { channel : DMA1_CH2 } , 9u8) ; dma_trait_impl ! (crate :: dac :: DacDma2 , DAC , { channel : DMA1_CH4 } , 15u8) ; dma_trait_impl ! (crate :: i2c :: TxDma , I2C1 , { channel : DMA1_CH2 } , 6u8) ; dma_trait_impl ! (crate :: i2c :: RxDma , I2C1 , { channel : DMA1_CH3 } , 6u8) ; dma_trait_impl ! (crate :: i2c :: TxDma , I2C1 , { channel : DMA1_CH6 } , 6u8) ; dma_trait_impl ! (crate :: i2c :: RxDma , I2C1 , { channel : DMA1_CH7 } , 6u8) ; dma_trait_impl ! (crate :: i2c :: TxDma , I2C2 , { channel : DMA1_CH4 } , 7u8) ; dma_trait_impl ! (crate :: i2c :: RxDma , I2C2 , { channel : DMA1_CH5 } , 7u8) ; dma_trait_impl ! (crate :: i2c :: TxDma , I2C3 , { channel : DMA1_CH2 } , 14u8) ; dma_trait_impl ! (crate :: i2c :: RxDma , I2C3 , { channel : DMA1_CH3 } , 14u8) ; dma_trait_impl ! (crate :: i2c :: TxDma , I2C3 , { channel : DMA1_CH4 } , 14u8) ; dma_trait_impl ! (crate :: i2c :: RxDma , I2C3 , { channel : DMA1_CH5 } , 14u8) ; dma_trait_impl ! (crate :: usart :: TxDma , LPUART1 , { channel : DMA1_CH2 } , 5u8) ; dma_trait_impl ! (crate :: usart :: RxDma , LPUART1 , { channel : DMA1_CH3 } , 5u8) ; dma_trait_impl ! (crate :: usart :: RxDma , LPUART1 , { channel : DMA1_CH6 } , 5u8) ; dma_trait_impl ! (crate :: usart :: TxDma , LPUART1 , { channel : DMA1_CH7 } , 5u8) ; dma_trait_impl ! (crate :: spi :: RxDma , SPI1 , { channel : DMA1_CH2 } , 1u8) ; dma_trait_impl ! (crate :: spi :: TxDma , SPI1 , { channel : DMA1_CH3 } , 1u8) ; dma_trait_impl ! (crate :: spi :: RxDma , SPI2 , { channel : DMA1_CH4 } , 2u8) ; dma_trait_impl ! (crate :: spi :: TxDma , SPI2 , { channel : DMA1_CH5 } , 2u8) ; dma_trait_impl ! (crate :: spi :: RxDma , SPI2 , { channel : DMA1_CH6 } , 2u8) ; dma_trait_impl ! (crate :: spi :: TxDma , SPI2 , { channel : DMA1_CH7 } , 2u8) ; dma_trait_impl ! (crate :: timer :: Ch3Dma , TIM2 , { channel : DMA1_CH1 } , 8u8) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM2 , { channel : DMA1_CH2 } , 8u8) ; dma_trait_impl ! (crate :: timer :: Ch2Dma , TIM2 , { channel : DMA1_CH3 } , 8u8) ; dma_trait_impl ! (crate :: timer :: Ch4Dma , TIM2 , { channel : DMA1_CH4 } , 8u8) ; dma_trait_impl ! (crate :: timer :: Ch1Dma , TIM2 , { channel : DMA1_CH5 } , 8u8) ; dma_trait_impl ! (crate :: timer :: Ch2Dma , TIM2 , { channel : DMA1_CH7 } , 8u8) ; dma_trait_impl ! (crate :: timer :: Ch4Dma , TIM2 , { channel : DMA1_CH7 } , 8u8) ; dma_trait_impl ! (crate :: timer :: Ch3Dma , TIM3 , { channel : DMA1_CH2 } , 10u8) ; dma_trait_impl ! (crate :: timer :: Ch4Dma , TIM3 , { channel : DMA1_CH3 } , 10u8) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM3 , { channel : DMA1_CH3 } , 10u8) ; dma_trait_impl ! (crate :: timer :: Ch1Dma , TIM3 , { channel : DMA1_CH5 } , 10u8) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM6 , { channel : DMA1_CH2 } , 9u8) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM7 , { channel : DMA1_CH4 } , 15u8) ; dma_trait_impl ! (crate :: usart :: TxDma , USART1 , { channel : DMA1_CH2 } , 3u8) ; dma_trait_impl ! (crate :: usart :: RxDma , USART1 , { channel : DMA1_CH3 } , 3u8) ; dma_trait_impl ! (crate :: usart :: TxDma , USART1 , { channel : DMA1_CH4 } , 3u8) ; dma_trait_impl ! (crate :: usart :: RxDma , USART1 , { channel : DMA1_CH5 } , 3u8) ; dma_trait_impl ! (crate :: usart :: TxDma , USART2 , { channel : DMA1_CH4 } , 4u8) ; dma_trait_impl ! (crate :: usart :: RxDma , USART2 , { channel : DMA1_CH5 } , 4u8) ; dma_trait_impl ! (crate :: usart :: RxDma , USART2 , { channel : DMA1_CH6 } , 4u8) ; dma_trait_impl ! (crate :: usart :: TxDma , USART2 , { channel : DMA1_CH7 } , 4u8) ; dma_trait_impl ! (crate :: usart :: RxDma , USART4 , { channel : DMA1_CH2 } , 12u8) ; dma_trait_impl ! (crate :: usart :: TxDma , USART4 , { channel : DMA1_CH3 } , 12u8) ; dma_trait_impl ! (crate :: usart :: RxDma , USART4 , { channel : DMA1_CH6 } , 12u8) ; dma_trait_impl ! (crate :: usart :: TxDma , USART4 , { channel : DMA1_CH7 } , 12u8) ; dma_trait_impl ! (crate :: usart :: RxDma , USART5 , { channel : DMA1_CH2 } , 13u8) ; dma_trait_impl ! (crate :: usart :: TxDma , USART5 , { channel : DMA1_CH3 } , 13u8) ; dma_trait_impl ! (crate :: usart :: RxDma , USART5 , { channel : DMA1_CH6 } , 13u8) ; dma_trait_impl ! (crate :: usart :: TxDma , USART5 , { channel : DMA1_CH7 } , 13u8) ; impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Hpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Hpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Hpre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV16 => self * 1u32 / 16u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV64 => self * 1u32 / 64u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV128 => self * 1u32 / 128u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV256 => self * 1u32 / 256u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV512 => self * 1u32 / 512u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Hpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Hpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Hpre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV16 => self * 16u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV64 => self * 64u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV128 => self * 128u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV256 => self * 256u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV512 => self * 512u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Mcopre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Mcopre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Mcopre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV16 => self * 1u32 / 16u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Mcopre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Mcopre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Mcopre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV16 => self * 16u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Plldiv > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Plldiv) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Plldiv :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Plldiv :: DIV3 => self * 1u32 / 3u32 , crate :: pac :: rcc :: vals :: Plldiv :: DIV4 => self * 1u32 / 4u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Plldiv > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Plldiv) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Plldiv :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Plldiv :: DIV3 => self * 3u32 / 1u32 , crate :: pac :: rcc :: vals :: Plldiv :: DIV4 => self * 4u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Pllmul > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Pllmul) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Pllmul :: MUL3 => self * 1u32 / 3u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL6 => self * 1u32 / 6u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL12 => self * 1u32 / 12u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL16 => self * 1u32 / 16u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL24 => self * 1u32 / 24u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL32 => self * 1u32 / 32u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL48 => self * 1u32 / 48u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Pllmul > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Pllmul) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Pllmul :: MUL3 => self * 3u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL6 => self * 6u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL12 => self * 12u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL16 => self * 16u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL24 => self * 24u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL32 => self * 32u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL48 => self * 48u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Ppre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Ppre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Ppre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV16 => self * 1u32 / 16u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Ppre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Ppre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Ppre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV16 => self * 16u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Rtcpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Rtcpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Rtcpre :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Rtcpre :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Rtcpre :: DIV8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Rtcpre :: DIV16 => self * 1u32 / 16u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Rtcpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Rtcpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Rtcpre :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Rtcpre :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Rtcpre :: DIV8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Rtcpre :: DIV16 => self * 16u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } # [allow (non_camel_case_types)] pub mod peripheral_interrupts { pub mod ADC { pub type GLOBAL = crate :: interrupt :: typelevel :: ADC1_COMP ; } pub mod ADC_COMMON { } pub mod COMP1 { pub type WKUP = crate :: interrupt :: typelevel :: ADC1_COMP ; } pub mod COMP2 { pub type WKUP = crate :: interrupt :: typelevel :: ADC1_COMP ; } pub mod CRC { } pub mod CRS { } pub mod DAC { pub type GLOBAL = crate :: interrupt :: typelevel :: TIM6_DAC ; } pub mod DBGMCU { } pub mod DMA1 { pub type CH1 = crate :: interrupt :: typelevel :: DMA1_CHANNEL1 ; pub type CH2 = crate :: interrupt :: typelevel :: DMA1_CHANNEL2_3 ; pub type CH3 = crate :: interrupt :: typelevel :: DMA1_CHANNEL2_3 ; pub type CH4 = crate :: interrupt :: typelevel :: DMA1_CHANNEL4_5_6_7 ; pub type CH5 = crate :: interrupt :: typelevel :: DMA1_CHANNEL4_5_6_7 ; pub type CH6 = crate :: interrupt :: typelevel :: DMA1_CHANNEL4_5_6_7 ; pub type CH7 = crate :: interrupt :: typelevel :: DMA1_CHANNEL4_5_6_7 ; } pub mod EXTI { pub type EXTI0 = crate :: interrupt :: typelevel :: EXTI0_1 ; pub type EXTI1 = crate :: interrupt :: typelevel :: EXTI0_1 ; pub type EXTI10 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI11 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI12 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI13 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI14 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI15 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI2 = crate :: interrupt :: typelevel :: EXTI2_3 ; pub type EXTI3 = crate :: interrupt :: typelevel :: EXTI2_3 ; pub type EXTI4 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI5 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI6 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI7 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI8 = crate :: interrupt :: typelevel :: EXTI4_15 ; pub type EXTI9 = crate :: interrupt :: typelevel :: EXTI4_15 ; } pub mod FLASH { pub type GLOBAL = crate :: interrupt :: typelevel :: FLASH ; } pub mod GPIOA { } pub mod GPIOB { } pub mod GPIOC { } pub mod GPIOD { } pub mod GPIOE { } pub mod GPIOH { } pub mod I2C1 { pub type ER = crate :: interrupt :: typelevel :: I2C1 ; pub type EV = crate :: interrupt :: typelevel :: I2C1 ; } pub mod I2C2 { pub type ER = crate :: interrupt :: typelevel :: I2C2 ; pub type EV = crate :: interrupt :: typelevel :: I2C2 ; } pub mod I2C3 { pub type ER = crate :: interrupt :: typelevel :: I2C3 ; pub type EV = crate :: interrupt :: typelevel :: I2C3 ; } pub mod IWDG { } pub mod LPTIM1 { pub type GLOBAL = crate :: interrupt :: typelevel :: LPTIM1 ; } pub mod LPUART1 { pub type GLOBAL = crate :: interrupt :: typelevel :: RNG_LPUART1 ; } pub mod PWR { } pub mod RCC { pub type CRS = crate :: interrupt :: typelevel :: RCC_CRS ; pub type RCC = crate :: interrupt :: typelevel :: RCC_CRS ; } pub mod RNG { pub type GLOBAL = crate :: interrupt :: typelevel :: RNG_LPUART1 ; } pub mod RTC { pub type ALARM = crate :: interrupt :: typelevel :: RTC ; pub type SSRU = crate :: interrupt :: typelevel :: RTC ; pub type STAMP = crate :: interrupt :: typelevel :: RTC ; pub type TAMP = crate :: interrupt :: typelevel :: RTC ; pub type WKUP = crate :: interrupt :: typelevel :: RTC ; } pub mod SPI1 { pub type GLOBAL = crate :: interrupt :: typelevel :: SPI1 ; } pub mod SPI2 { pub type GLOBAL = crate :: interrupt :: typelevel :: SPI2 ; } pub mod SYSCFG { } pub mod TIM2 { pub type BRK = crate :: interrupt :: typelevel :: TIM2 ; pub type CC = crate :: interrupt :: typelevel :: TIM2 ; pub type COM = crate :: interrupt :: typelevel :: TIM2 ; pub type TRG = crate :: interrupt :: typelevel :: TIM2 ; pub type UP = crate :: interrupt :: typelevel :: TIM2 ; } pub mod TIM21 { pub type BRK = crate :: interrupt :: typelevel :: TIM21 ; pub type CC = crate :: interrupt :: typelevel :: TIM21 ; pub type COM = crate :: interrupt :: typelevel :: TIM21 ; pub type TRG = crate :: interrupt :: typelevel :: TIM21 ; pub type UP = crate :: interrupt :: typelevel :: TIM21 ; } pub mod TIM22 { pub type BRK = crate :: interrupt :: typelevel :: TIM22 ; pub type CC = crate :: interrupt :: typelevel :: TIM22 ; pub type COM = crate :: interrupt :: typelevel :: TIM22 ; pub type TRG = crate :: interrupt :: typelevel :: TIM22 ; pub type UP = crate :: interrupt :: typelevel :: TIM22 ; } pub mod TIM3 { pub type BRK = crate :: interrupt :: typelevel :: TIM3 ; pub type CC = crate :: interrupt :: typelevel :: TIM3 ; pub type COM = crate :: interrupt :: typelevel :: TIM3 ; pub type TRG = crate :: interrupt :: typelevel :: TIM3 ; pub type UP = crate :: interrupt :: typelevel :: TIM3 ; } pub mod TIM6 { pub type BRK = crate :: interrupt :: typelevel :: TIM6_DAC ; pub type CC = crate :: interrupt :: typelevel :: TIM6_DAC ; pub type COM = crate :: interrupt :: typelevel :: TIM6_DAC ; pub type TRG = crate :: interrupt :: typelevel :: TIM6_DAC ; pub type UP = crate :: interrupt :: typelevel :: TIM6_DAC ; } pub mod TIM7 { pub type BRK = crate :: interrupt :: typelevel :: TIM7 ; pub type CC = crate :: interrupt :: typelevel :: TIM7 ; pub type COM = crate :: interrupt :: typelevel :: TIM7 ; pub type TRG = crate :: interrupt :: typelevel :: TIM7 ; pub type UP = crate :: interrupt :: typelevel :: TIM7 ; } pub mod TSC { pub type GLOBAL = crate :: interrupt :: typelevel :: TSC ; } pub mod UID { } pub mod USART1 { pub type GLOBAL = crate :: interrupt :: typelevel :: USART1 ; } pub mod USART2 { pub type GLOBAL = crate :: interrupt :: typelevel :: USART2 ; } pub mod USART4 { pub type GLOBAL = crate :: interrupt :: typelevel :: USART4_5 ; } pub mod USART5 { pub type GLOBAL = crate :: interrupt :: typelevel :: USART4_5 ; } pub mod USB { pub type HP = crate :: interrupt :: typelevel :: USB ; pub type LP = crate :: interrupt :: typelevel :: USB ; pub type WKUP = crate :: interrupt :: typelevel :: USB ; } pub mod USBRAM { } pub mod WWDG { pub type GLOBAL = crate :: interrupt :: typelevel :: WWDG ; pub type RST = crate :: interrupt :: typelevel :: WWDG ; } } dma_channel_impl ! (DMA1_CH1 , 0u8) ; dma_channel_impl ! (DMA1_CH2 , 1u8) ; dma_channel_impl ! (DMA1_CH3 , 2u8) ; dma_channel_impl ! (DMA1_CH4 , 3u8) ; dma_channel_impl ! (DMA1_CH5 , 4u8) ; dma_channel_impl ! (DMA1_CH6 , 5u8) ; dma_channel_impl ! (DMA1_CH7 , 6u8) ; # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA1_CHANNEL1 () { < crate :: peripherals :: DMA1_CH1 as crate :: dma :: ChannelInterrupt > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA1_CHANNEL2_3 () { < crate :: peripherals :: DMA1_CH2 as crate :: dma :: ChannelInterrupt > :: on_irq () ; < crate :: peripherals :: DMA1_CH3 as crate :: dma :: ChannelInterrupt > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA1_CHANNEL4_5_6_7 () { < crate :: peripherals :: DMA1_CH4 as crate :: dma :: ChannelInterrupt > :: on_irq () ; < crate :: peripherals :: DMA1_CH5 as crate :: dma :: ChannelInterrupt > :: on_irq () ; < crate :: peripherals :: DMA1_CH6 as crate :: dma :: ChannelInterrupt > :: on_irq () ; < crate :: peripherals :: DMA1_CH7 as crate :: dma :: ChannelInterrupt > :: on_irq () ; } pub (crate) const DMA_CHANNELS : & [crate :: dma :: ChannelInfo] = & [crate :: dma :: ChannelInfo { dma : crate :: dma :: DmaInfo :: Bdma (crate :: pac :: DMA1) , num : 0usize , } , crate :: dma :: ChannelInfo { dma : crate :: dma :: DmaInfo :: Bdma (crate :: pac :: DMA1) , num : 1usize , } , crate :: dma :: ChannelInfo { dma : crate :: dma :: DmaInfo :: Bdma (crate :: pac :: DMA1) , num : 2usize , } , crate :: dma :: ChannelInfo { dma : crate :: dma :: DmaInfo :: Bdma (crate :: pac :: DMA1) , num : 3usize , } , crate :: dma :: ChannelInfo { dma : crate :: dma :: DmaInfo :: Bdma (crate :: pac :: DMA1) , num : 4usize , } , crate :: dma :: ChannelInfo { dma : crate :: dma :: DmaInfo :: Bdma (crate :: pac :: DMA1) , num : 5usize , } , crate :: dma :: ChannelInfo { dma : crate :: dma :: DmaInfo :: Bdma (crate :: pac :: DMA1) , num : 6usize , } ,] ;